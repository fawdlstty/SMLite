<HTML>
<Head>
<Title>c_map</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<!--end header-->
<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>c_map</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
<tt>Map</tt> is a <!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>--> that associates objects of
type <tt>Key</tt> with objects of type <tt>Data</tt>.  <tt>Map</tt> is a 
<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->, meaning that its value type is
<tt><A href="pair.html">c_pair</A></tt>.  It is also a 
<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->, meaning that no two elements have
the same key.
<P>
<tt>Map</tt> has the important property that inserting a new element
into a <tt>map</tt> does not invalidate iterators that point to existing
elements.  Erasing an element from a <tt>map</tt> also does not invalidate
any iterators, except, of course, for iterators that actually point 
to the element that is being erased.
<h3>Example</h3>
<pre>

struct key
{
	int k;
};

int key_comparer(value_type x, value_type y)
{
	return ((struct key *)(x))->k - ((struct key *)(y))->k;
}

c_pair pair_ary[] = 
{
	{ 0, 0 }
};

int main()
{
	c_map map;
	struct key * pkey = malloc(size_of(struct key));
	pkey->k = 0xf;
	pair_ary[0].first = pkey;
	c_map_create(&map, key_comparer);
	c_map_insert(&map, &pair_ary[0]);
	c_map_destroy(&map);
	free(pkey);
}

</pre>
<h3>Definition</h3>
Defined in the standard header <A href="../../include/c_map.h">c_map.h</A>.
<h3>Model of</h3>
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, <!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
<h3>Type requirements</h3>
<UL>
<LI>
<tt>Data</tt> is <A href="Assignable.html">Assignable</A>.
<LI>
<tt>Compare</tt> is a <!--<A href="StrictWeakOrdering.html">-->Strict Weak Ordering<!--</A>--> whose argument type
   is <tt>Key</tt>.
<LI>
<tt>Alloc</tt> is an <!--<A href="Allocators.html">-->Allocator<!--</A>-->.
</UL>
<h3>Public base classes</h3>
None.
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>key_type</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
The <tt>map</tt>'s key type, <tt>Key</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>data_type</tt>
</TD>
<TD VAlign=top>
	<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
The type of object associated with the keys.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type</tt>
</TD>
<TD VAlign=top>
	<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
The type of object, <tt>pair&lt;const key_type, data_type&gt;</tt>, stored in the map.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>key_compare</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
 <A href="functors.html">Function object</A> that compares two keys for ordering.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_compare</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
 <A href="functors.html">Function object</A> that compares two values for ordering.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>pointer</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Pointer to <tt>T</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
An unsigned integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>difference_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
A signed integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate through a <tt>map</tt>. <A href="#1">[1]</A>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate through a <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Iterator used to iterate backwards through a <tt>map</tt>. <A href="#1">[1]</A>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Const iterator used to iterate backwards through a <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_map_begin(c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the beginning of the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_map_end(c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the end of the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_map_rbegin(c_pmap)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
   reversed map.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_map_rend(c_pmap)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the end of the
   reversed map.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_map_size(c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the size of the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_map_max_size(c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the largest possible size of the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_bool c_map_empty(c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
<tt>true</tt> if the <tt>map</tt>'s size is <tt>0</tt>.
</TD>
</TR>
<!--
<TR>
<TD VAlign=top>
<tt>key_compare key_comp() const</tt>
</TD>
<TD VAlign=top>
 <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>key_compare</tt> object used by the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_compare value_comp() const</tt>
</TD>
<TD VAlign=top>
 <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>value_compare</tt> object used by the <tt>map</tt>.
</TD>
</TR>
-->
<TR>
<TD VAlign=top>
<tt>__c_map(c_pmap, COMPARER) or c_map_create(c_pmap, COMPARER)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Creates an empty <tt>map</tt>, using <tt>comp</tt> as the <tt>key_compare</tt> object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_pmap c_map_assign(c_pmap, const c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The assignment operator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_map_swap(c_pmap, c_pmap)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two maps.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iter_bool_pair
c_map_insert(c_pmap, const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> into the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iterator c_map_insert1(c_pmap, c_iterator pos,
                		const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> into the <tt>map</tt>, using <tt>pos</tt> as a hint to where it will be
   inserted.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
void c_map_insert2(c_pmap, c_iterator, c_iterator)
<A href="#2">[2]</A>
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts a range into the <tt>map</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_map_erase(c_pmap, c_iterator pos)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases the element pointed to by <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_map_erase1(c_pmap, const key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases the element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_map_erase2(c_pmap, c_iterator first, c_iterator last)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases all elements in a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_map_clear(c_pmap)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases all of the elements.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_map_find(c_pmap, const key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds an element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_map_count(c_pmap, const key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Counts the number of elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_map_lower_bound(c_pmap, const key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds the first element whose key is not less than <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_map_upper_bound(c_pmap, const key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds the first element whose key greater than <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iter_iter_pair
c_map_equal_range(c_pmap, const key_type k)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds a range containing all elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
value_type c_map_at(c_pmap, const key_type k) <A href="#3">[3]</A>
</pre>
</TD>
<TD VAlign=top>
<tt>map</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_map_equal(c_pmap, c_pmap, COMPARER)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Tests two maps for equality.  This is a global function, not
   a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_map_less(c_pmap, c_pmap, COMPARER)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Lexicographical comparison.  This is a global function, not
   a member function.
</TD>
</tr>
</table>
<h3>New members</h3>
These members are not defined in the 
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>--> and <!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
requirements, but are unique to <tt>map</tt>:
<Table border>
<TR>
<TH>
Member function
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<pre>
value_type c_map_at(c_pmap, key_type k) <A href="#3">[3]</A>
</pre>
</TD>
<TD VAlign=top>
Returns a reference to the object that is associated with
   a particular key.  If the <tt>map</tt> does not already contain such
   an object, <tt>operator[]</tt> inserts the default object <tt>data_type()</tt>. <A href="#3">[3]</A>
</TD>
</tr>
</table>
<h3>Notes</h3>
<P><A name="1">[1]</A>
<tt>Map::iterator</tt> is not a mutable iterator, because
<tt>map::value_type</tt> is not <A href="Assignable.html">Assignable</A>.  That is, if <tt>i</tt> is of
type <tt>map::iterator</tt> and <tt>p</tt> is of type
<tt>map::value_type</tt>, then <tt>*i = p</tt> is not a valid
expression.  However, <tt>map::iterator</tt> isn't a constant iterator
either, because it can be used to modify the object that it points to.
Using the same notation as above, <tt>(*i).second = p</tt> is a valid
expression.  The same point applies to <tt>map::reverse_iterator</tt>.
<P><A name="2">[2]</A>
This member function relies on <i>member template</i> functions, which
at present (early 1998) are not supported by all compilers.  If your
compiler supports member templates, you can call this function with
any type of <A href="InputIterator.html">input iterator</A>.  If your
compiler does not yet support member templates, though, then the
arguments must either be of type <tt>const value_type*</tt> or of type
<tt>map::const_iterator</tt>.
<P><A name="3">[3]</A>
Since <tt>operator[]</tt> might insert a new element into the <tt>map</tt>,
it can't possibly be a <tt>const</tt> member function.  Note that the 
definition of <tt>operator[]</tt> is extremely simple: <tt>m[k]</tt> is equivalent
to <tt>(*((m.insert(value_type(k, data_type()))).first)).second</tt>.
Strictly speaking, this member function is unnecessary: it exists
only for convenience.
<h3>See also</h3>
<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->, <!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->, 
<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->, <!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
<tt><A href="set.html">set</A></tt>
<!--
<tt><A href="multiset.html">multiset</A></tt>, <tt><A href="Multimap.html">multimap</A></tt>,
<tt><A href="hash_set.html">hash_set</A></tt>, <tt><A href="hash_map.html">hash_map</A></tt>, 
<tt><A href="hash_multiset.html">hash_multiset</A></tt>, <tt><A href="hash_multimap.html">hash_multimap</A></tt>,
-->
<!--start footer--> 
<HR SIZE="6">
<p>
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
