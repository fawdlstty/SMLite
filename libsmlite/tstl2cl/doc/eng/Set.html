<HTML>
<Head>
<Title>c_set</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<!--end header-->
<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>c_set</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
<tt>Set</tt> is a
<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>--> that stores objects of type <tt>Key</tt>.
<tt>Set</tt> is a
<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->, 
meaning that its value type, as well as its 
key type, is <tt>Key</tt>.  It is also a
<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->,
meaning that no two elements are the same.
<P>
<tt>Set</tt> and <tt><!--<A href="multiset.html">-->multiset<!--</A>--></tt> are
particularly well suited to the set algorithms
<tt><!--<A href="includes.html">-->includes<!--</A>--></tt>,
<tt><!--<A href="set_union.html">-->set_union<!--</A>--></tt>,
<tt><!--<A href="set_intersection.html">-->set_intersection<!--</A>--></tt>,
<tt><!--<A href="set_difference.html">-->set_difference<!--</A>--></tt>, and
<tt><!--<A href="set_symmetric_difference.html">-->set_symmetric_difference<!--</A>--></tt>.
The reason for this is twofold.  First, the set algorithms require
their arguments to be sorted ranges, and, since
<tt><A href="set.html">set</A></tt> and 
<tt><!--<A href="multiset.html">-->multiset<!--</A>--></tt> are 
<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Containers<!--</A>-->, 
their elements are always sorted in ascending order. 
Second, the output range of these algorithms is always sorted, and
inserting a sorted range into a <tt>set</tt> or <tt>multiset</tt> is a
fast operation: the
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>--> 
and <!--<A href="MultipleSortedAssociativeContainer.html">-->Multiple Sorted Associative Container<!--</A>-->
requirements guarantee that inserting a
range takes only linear time if the range is already sorted.
<P>
<tt>Set</tt> has the important property that inserting a new element
into a <tt>set</tt> does not invalidate iterators that point to existing
elements.  Erasing an element from a set also does not invalidate
any iterators, except, of course, for iterators that actually point 
to the element that is being erased.
<h3>Example</h3>
<pre>

int main()
{
	c_set S;
	c_set_create(&S, NULL);
	c_set_insert(&S, 0);
	c_set_destroy(&S);
}
</pre>
<h3>Definition</h3>
Defined in the standard header <A href="../../include/c_set.h">c_set.h</A>.
<h3>Model of</h3>
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->
<h3>Type requirements</h3>
<UL>
<LI>
<tt>Key</tt> is <!--<A href="Assignable.html">-->Assignable<!--</A>-->.
<LI>
<tt>Compare</tt> is a <!--<A href="StrictWeakOrdering.html">-->Strict Weak Ordering<!--</A>--> whose argument type
   is <tt>Key</tt>.
<LI>
<tt>Alloc</tt> is an <!--<A href="Allocators.html">-->Allocator<!--</A>-->.
</UL>
<h3>Public base classes</h3>
None.
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The type of object, <tt>T</tt>, stored in the set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>key_type</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
The key type associated with <tt>value_type</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>key_compare</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
 <A href="functors.html">Function object</A> that compares two keys for ordering.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_compare</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
 <A href="functors.html">Function object</A> that compares two values for ordering.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>pointer</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Pointer to <tt>T</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
An unsigned integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>difference_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
A signed integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate through a <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate through a <tt>set</tt>.  (<tt>Iterator</tt> and
   <tt>const_iterator</tt> are the same type.)
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Iterator used to iterate backwards through a <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Const iterator used to iterate backwards through a <tt>set</tt>.
  (<tt>Reverse_iterator</tt> and <tt>const_reverse_iterator</tt> are the same type.)
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_set_begin(c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the beginning of the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_set_end(c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the end of the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_set_rbegin(cpset)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
   reversed set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_set_rend(cpset)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>reverse_iterator</tt> pointing to the end of the
   reversed set.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_set_size(c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the size of the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_set_max_size(c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the largest possible size of the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_bool c_set_empty(c_pset) const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
<tt>true</tt> if the <tt>set</tt>'s size is <tt>0</tt>.
</TD>
</TR>
<!--
<TR>
<TD VAlign=top>
<tt>key_compare key_comp() const</tt>
</TD>
<TD VAlign=top>
 <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>key_compare</tt> object used by the <tt>set</tt>.
</TD>
</TR>
-->
<!--
<TR>
<TD VAlign=top>
<tt>value_compare value_comp() const</tt>
</TD>
<TD VAlign=top>
 <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Returns the <tt>value_compare</tt> object used by the <tt>set</tt>.
</TD>
</TR>
-->
<TR>
<TD VAlign=top>
<tt>__c_set(c_pset, COMPARER) or c_set_create(c_pset, COMPARER)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>set</tt>.
</TD>
</TR>
<!--
<TR>
<TD VAlign=top>
<tt>set(const key_compare&amp; comp)</tt>
</TD>
<TD VAlign=top>
 <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Creates an empty <tt>set</tt>, using <tt>comp</tt> as the <tt>key_compare</tt> object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
set(InputIterator f, InputIterator l)
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueSortedAssociativeContainer.html">Unique Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Creates a set with a copy of a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
set(InputIterator f, InputIterator l,
    const key_compare&amp; comp)
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="UniqueSortedAssociativeContainer.html">Unique Sorted Associative Container</A>
</TD>
<TD VAlign=top>
Creates a set with a copy of a range, using <tt>comp</tt> as the <tt>key_compare</tt>
   object.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>set(const set&amp;)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The copy constructor.
</TD>
</TR>
-->
<TR>
<TD VAlign=top>
<tt>c_set_assign(c_pset, const c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The assignment operator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_set_swap(c_pset, c_pset)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two sets.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iter_bool_pair
c_set_insert(c_pset, const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> into the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iterator c_set_insert1(c_pset, c_iterator pos, 
   	         	    const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> into the <tt>set</tt>, using <tt>pos</tt> as a hint to where it will be
   inserted.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
void c_set_insert2(c_pset, c_iterator, c_iterator)
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Inserts a range into the <tt>set</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_set_erase(c_pset, c_iterator pos)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases the element pointed to by <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_set_erase1(c_pset,  key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases the element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_set_erase2(c_pset, c_iterator first, c_iterator last)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases all elements in a range.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_set_clear(c_pset)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Erases all of the elements.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_set_find(c_pset, key_type k) </tt>
</TD>
<TD VAlign=top>
	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds an element whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_set_count(c_pset, key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Counts the number of elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_set_lower_bound(c_pset, key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds the first element whose key is not less than <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_set_upper_bound(c_pset, key_type k)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds the first element whose key greater than <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iter_iter_pair
c_set_equal_range(c_pset, const key_type k)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
</TD>
<TD VAlign=top>
Finds a range containing all elements whose key is <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_set_equal(c_pset, const c_pset)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Tests two sets for equality.  This is a global function, not
   a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_set_less(c_pset, const c_pset)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Lexicographical comparison.  This is a global function, not
   a member function.
</TD>
</tr>
</table>
<h3>New members</h3>
All of <tt>set</tt>'s members are defined in the 
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
and <!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->
requirements.  <tt>Set</tt> does not introduce any new members.
<h3>Notes</h3>
<P><A name="1">[1]</A>
This member function relies on <i>member template</i> functions, which
at present (early 1998) are not supported by all compilers.  If your
compiler supports member templates, you can call this function with
any type of <A href="InputIterator.html">input iterator</A>.  If your
compiler does not yet support member templates, though, then the
arguments must either be of type <tt>const value_type*</tt> or of type
<tt>set::const_iterator</tt>.
<h3>See also</h3>
<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->, 
<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->, 
<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->,
<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
<tt><A href="Map.html">map</A></tt>,
<!--<tt><A href="multiset.html">multiset</A></tt>,
<tt><A href="Multimap.html">multimap</A></tt>,
<tt><A href="hash_set.html">hash_set</A></tt>, 
<tt><A href="hash_map.html">hash_map</A></tt>, 
<tt><A href="hash_multiset.html">hash_multiset</A></tt>, 
<tt><A href="hash_multimap.html">hash_multimap</A></tt>
-->
<!--start footer--> 
<HR SIZE="6">
<P>
<p>
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
