<HTML>
<Head>
<Title>c_vector</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<!--end header-->
<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>c_vector</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: type</TD>
</TR>
</Table>

<h3>Description</h3>
A <tt>vector</tt> is a <!--<A href="Sequence.html">-->Sequence<!--</A>--> that
supports random access to elements, constant time insertion and
removal of elements at the end, and linear time insertion and removal
of elements at the beginning or in the middle.  The number of elements
in a <tt>vector</tt> may vary dynamically; memory management is
automatic.  <tt>Vector</tt> is the simplest of the STL container
classes, and in many cases the most efficient.
<h3>Example</h3>
<pre>
c_vector V;
c_vector_create(&V, NULL);
c_vector_insert(&V, V.begin(), malloc(sizeof(int)));
assert(c_vector_size(&V) == 1 &amp;&amp; c_vector_capacity(&V) &gt;= 1);
c_vector_destroy(&V);
</pre>
<h3>Definition</h3>
Defined in the standard header <A href="../../include/c_vector.h">c_vector.h</A>.
<h3>Model of</h3>
<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>-->, 
<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
<h3>Type requirements</h3>
None, except for those imposed by the requirements of 
<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>--> 
and <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
<h3>Public base classes</h3>
None.  
<h3>Members</h3>
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Where defined
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The type of object, <tt>T</tt>, stored in the vector.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>pointer</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Pointer to <tt>T</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
An unsigned integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>difference_type</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
A signed integral type.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Iterator used to iterate through a <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_iterator</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Const iterator used to iterate through a <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Iterator used to iterate backwards through a <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>const_reverse_iterator</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Const iterator used to iterate backwards through a <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_vector_begin(c_pvector )</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the beginning of the <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_vector_end(c_pvector )</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns an <tt>iterator</tt> pointing to the end of the <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_vector_rbegin(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>c_reverse_iterator</tt> pointing to the beginning of the
   reversed vector.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_reverse_iterator c_vector_rend(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns a <tt>c_reverse_iterator</tt> pointing to the end of the
   reversed vector.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_vector_size(c_pvector )</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the size of the <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type max_size(c_pvector ) </tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Returns the largest possible size of the <tt>vector</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_vector_capacity(c_pvector )</tt>
</TD>
<TD VAlign=top>
<tt>vector</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_bool c_vector_empty(c_pvector ) const</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
<tt>true</tt> if the <tt>vector</tt>'s size is <tt>0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type c_vector_at(c_pvector , size_type )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>-->
</TD>
<TD VAlign=top>
Returns the <tt>n</tt>'th element.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>__c_vector(c_pvector , COMPARER) or c_vector_create(c_pvector, COMPARER)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Creates an empty vector.
</TD>
</TR>
<!--
<TR>
<TD VAlign=top>
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
vector(InputIterator, InputIterator)
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
 <A href="Sequence.html">Sequence</A>
</TD>
<TD VAlign=top>
Creates a vector with a copy of a range.
</TD>
</TR>
-->
<TR>
<TD VAlign=top>
<tt>__rotcev(c_pvector ) or c_vector_destroy(c_pvector )</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The destructor.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_pvector c_vector_assign(c_pvector, c_pvector)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
The assignment operator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_reserve(size_t)</tt>
</TD>
<TD VAlign=top>
<tt>vector</tt>
</TD>
<TD VAlign=top>
See below.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type c_vector_front(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Returns the first element.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>value_type c_vector_back(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Returns the last element.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_push_back(const value_type)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Inserts a new element at the end.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_pop_back(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Removes the last element.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_swap(c_pvector, c_pvector)</tt>
</TD>
<TD VAlign=top>
 <A href="Container.html">Container</A>
</TD>
<TD VAlign=top>
Swaps the contents of two vectors.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_iterator c_vector_insert(c_iterator pos,
                const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>x</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
void c_vector_insert2(c_pvector, c_iterator pos, c_iterator first, c_iterator last);
<A href="#1">[1]</A>
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Inserts the range <tt>[first, last)</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
void c_vector_fill_insert(c_pvector, c_iterator pos, 
            			size_type n, const value_type x)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Inserts <tt>n</tt> copies of <tt>x</tt> before <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_vector_erase(c_pvector, c_iterator pos)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Erases the element at position <tt>pos</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c_iterator c_vector_erase(c_pvector, c_iterator first, c_iterator last)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Erases the range <tt>[first, last)</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_clear(c_pvector )</tt>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Erases all of the elements.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>void c_vector_resize(c_pvector, size_t n)</tt>
</TD>
<TD VAlign=top>
	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
</TD>
<TD VAlign=top>
Inserts or erases elements at the end such that the size becomes <tt>n</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_vector_equal(c_pvector, 
                	const c_pvector)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Tests two vectors for equality.  This is a global function, not
   a member function.
</TD>
</TR>
<TR>
<TD VAlign=top>
<pre>
c_bool c_vector_less(c_pvector,  
               		const c_pvector)
</pre>
</TD>
<TD VAlign=top>
	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
</TD>
<TD VAlign=top>
Lexicographical comparison.  This is a global function, not
   a member function.
</TD>
</tr>
</table>
<h3>New members</h3>
These members are not defined in the 
<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>--> 
and <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
requirements, but are specific to <tt>vector</tt>.
<Table border>
<TR>
<TH>
Member
</TH>
<TH>
Description
</TH>
</TR>
<TR>
<TD VAlign=top>
<tt>size_type c_vector_capacity(c_pvector)</tt>
</TD>
<TD VAlign=top>
Number of elements for which memory has been allocated.
   <tt>capacity()</tt> is always greater than or equal to <tt>size()</tt>.
   <A href="#2">[2]</A> <A href="#3">[3]</A>
</TD>
</TR>
<!--
<TR>
<TD VAlign=top>
<tt>void reserve(size_type n)</tt>
</TD>
<TD VAlign=top>
If <tt>n</tt> is less than or equal to <tt>capacity()</tt>, this call has no effect.
    Otherwise, it is a request for allocation of additional 
    memory.  If the request is successful, then <tt>capacity()</tt> is
    greater than or equal to <tt>n</tt>; otherwise, <tt>capacity()</tt> is unchanged.
    In either case, <tt>size()</tt> is unchanged.  
    <A href="#2">[2]</A> <A href="#4">[4]</A>
</TD>
</tr>
-->
</table>
<h3>Notes</h3>
<P><A name="1">[1]</A>
This member function relies on <i>member template</i> functions, which
at present (early 1998) are not supported by all compilers.  If your
compiler supports member templates, you can call this function with
any type of <A href="InputIterator.html">input iterator</A>.  If your
compiler does not yet support member templates, though, then the
arguments must be of type <tt>const value_type*</tt>.
<P><A name="2">[2]</A>
Memory will be reallocated automatically if more than <tt>capacity() -
size()</tt> elements are inserted into the vector.  Reallocation does
not change <tt>size()</tt>, nor does it change the values of any
elements of the vector.  It does, however, increase
<tt>capacity()</tt>, and it invalidates <A href="#5">[5]</A> any
iterators that point into the vector.
<P><A name="3">[3]</A>
When it is necessary to increase <tt>capacity()</tt>, <tt>vector</tt>
usually increases it by a factor of two.  It is crucial that the
amount of growth is proportional to the current <tt>capacity()</tt>,
rather than a fixed constant: in the former case inserting a series of
elements into a vector is a linear time operation, and in the latter
case it is quadratic.
<P><A name="4">[4]</A>
<tt>Reserve()</tt> causes a reallocation manually.  The main reason
for using <tt>reserve()</tt> is efficiency: if you know the capacity
to which your <tt>vector</tt> must eventually grow, then it is usually
more efficient to allocate that memory all at once rather than relying
on the automatic reallocation scheme.  The other reason for using
<tt>reserve()</tt> is so that you can control the invalidation of
iterators. <A href="#5">[5]</A>
<P><A name="5">[5]</A>
A vector's iterators are invalidated when its memory is reallocated.
Additionally, inserting or deleting an element in the middle of a
vector invalidates all iterators that point to elements following the
insertion or deletion point.  It follows that you can prevent a
vector's iterators from being invalidated if you use
<tt>reserve()</tt> to preallocate as much memory as the vector will
ever use, and if all insertions and deletions are at the vector's end.
<h3>See also</h3>
<!--<A href="Deque.html">deque</A>,--> 
<A href="List.html">list</A>
<!--, <A href="Slist.html">slist</A>-->

<!--start footer--> 
<HR SIZE="6">
<!--
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
-->
<P>
<p>
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
