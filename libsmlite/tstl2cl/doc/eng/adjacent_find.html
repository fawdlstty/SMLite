<HTML>
<Head>
<Title>adjacent_find</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
	<!--end header-->
	<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>c_adjacent_find</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
<TD Align=right VAlign=top><b>Component type</b>: function</TD>
</TR>
</Table>

<h3>Prototype</h3>
<tt>Adjacent_find</tt> is an overloaded name; there are actually two <tt>adjacent_find</tt>
functions.
<pre>

c_iterator c_adjacent_find(c_iterator first, c_iterator last,
                              BINARY_PREDICATE binary_pred);
</pre>                   
<h3>Description</h3>
The first version of <tt>adjacent_find</tt>
returns the first iterator <tt>i</tt> such that <tt>i</tt> and <tt>i+1</tt>
are both valid iterators in <tt>[first, last)</tt>, and such that 
<tt>*i == *(i+1)</tt>.  It returns <tt>last</tt> if no such iterator exists.
<P>
The second version of <tt>adjacent_find</tt>
returns the first iterator <tt>i</tt> such that <tt>i</tt> and <tt>i+1</tt>
are both valid iterators in <tt>[first, last)</tt>, and such that 
<tt>binary_pred(*i, *(i+1))</tt> is <tt>true</tt>.  
It returns <tt>last</tt> if no such iterator exists.
<h3>Definition</h3>
Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
<h3>Requirements on types</h3>
For the first version:
<UL>
<LI>
<tt>ForwardIterator</tt> is a model of <A href="ForwardIterator.html">Forward Iterator</A>.
<LI>
<tt>ForwardIterator</tt>'s value type is <A href="EqualityComparable.html">Equality Comparable</A>.
</UL>
For the second version:
<UL>
<LI>
<tt>ForwardIterator</tt> is a model of <A href="ForwardIterator.html">Forward Iterator</A>.
<LI>
<tt>ForwardIterator</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
   first argument type and to its second argument type.
</UL>
<h3>Preconditions</h3>
<UL>
<LI>
<tt>[first, last)</tt> is a valid range.
</UL>
<h3>Complexity</h3>
Linear.  If <tt>first == last</tt> then no comparison are performed;
otherwise, at most <tt>(last - first) - 1</tt> comparisons.
<h3>Example</h3>
Find the first element that is greater than its successor.
<pre>

static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
static int * pary[] = { &ary[0], &ary[1], &ary[2],
			 &ary[3], &ary[4], &ary[5],
			 &ary[6], &ary[7], &ary[8],
			 &ary[9] };

static c_bool multi_equal_30(value_type x, value_type y)
{
	return  *(int*)(x) * *(int*)(y) == 30;
}

int main()
{
	c_iterator first = c_get_array_iterator((void**)&pary[0]);
	c_iterator last = c_get_array_iterator((void**)&pary[10]);
	c_iterator iter;

	printf("adjacent_find multi_equal_30 by array:\n");

	iter = c_adjacent_find(first, last, multi_equal_30);
	if(!ITER_EQUAL(iter, last))
	{
		printf("find : ");
		first = ITER_POSITIVE_N(iter, 1);
		printf("%d %d\n", *(int*)ITER_REF(iter), *(int*)ITER_REF(first));
	}
	else
		printf("not find!\n");

	return 0;	
}



</pre>
<h3>Notes</h3>
<h3>See also</h3>
<tt><A href="find.html">find</A></tt>, <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><A href="equal.html">equal</A></tt>, <tt><!--<A href="search.html">-->search<!--</A>--></tt>

<!--start footer--> 
<p>
<hr size="6">
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
