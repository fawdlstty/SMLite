<HTML>
<Head>
<Title>equal</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<!--end header-->
<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>c_equal</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
<TD Align=right VAlign=top><b>Component type</b>: function</TD>
</TR>
</Table>

<h3>Prototype</h3>
<tt>Equal</tt> is an overloaded name; there are actually two <tt>equal</tt>
functions.
<pre>

c_bool c_equal(c_iterator first1, c_iterator last1,
         	  c_iterator first2, c_binary_predicate binary_pred);
</pre>                   
<h3>Description</h3>
<tt>Equal</tt> returns <tt>true</tt> if the two ranges <tt>[first1, last1)</tt> and
<tt>[first2, first2 + (last1 - first1))</tt> are identical when compared
element-by-element, and otherwise returns <tt>false</tt>. <A href="#1">[1]</A>  
<P>
The first version of <tt>equal</tt> returns <tt>true</tt> if and only if
for every iterator <tt>i</tt> in <tt>[first1, last1)</tt>, 
<tt>*i == *(first2 + (i - first1))</tt>.  
The second version of <tt>equal</tt> returns <tt>true</tt> if and only if
for every iterator <tt>i</tt> in <tt>[first1, last1)</tt>, 
<tt>binary_pred(*i, *(first2 + (i - first1))</tt> is <tt>true</tt>.  
<h3>Definition</h3>
Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
<h3>Requirements on types</h3>
For the first version:
<UL>
<LI>
<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator1</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
<LI>
<tt>InputIterator2</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
<LI>
<tt>InputIterator1</tt>'s value type can be compared for equality with
   <tt>InputIterator2</tt>'s value type. 
</UL>
For the second version:
<UL>
<LI>
<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary Predicate</A>.
<LI>
<tt>InputIterator1</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
   first argument type.
<LI>
<tt>InputIterator2</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
   second argument type.
</UL>
<h3>Preconditions</h3>
<UL>
<LI>
<tt>[first1, last1)</tt> is a valid range.
<LI>
<tt>[first2, first2 + (last2 - last1))</tt> is a valid range.
</UL>
<h3>Complexity</h3>
Linear.  At most <tt>last1 - first1</tt> comparisons.
<h3>Example</h3>
<pre>
static int arx[] = { 0,1,2,3,4,5,6,7,8,9 };
static int * parx[] = { &ary[0], &ary[1], &ary[2],
			 &ary[3], &ary[4], &ary[5],
			 &ary[6], &ary[7], &ary[8],
			 &ary[9] };
static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
static int * pary[] = { &ary[0], &ary[1], &ary[2],
			 &ary[3], &ary[4], &ary[5],
			 &ary[6], &ary[7], &ary[8],
			 &ary[9] };

static int int_comparer(value_type x, value_type y)
{
	return *(int *)x - *(int *)y;
}

int main()
{
	c_iterator first = c_get_array_iterator((void**)&parx[0]);
	c_iterator last = c_get_array_iterator((void**)&parx[10]);
	c_iterator first2 = c_get_array_iterator((void**)&pary[0]);

	c_binary_predicate bp =  c_binary_negate(int_comparer);
	
	assert(c_equal(first, last, first2, bp));
}

</pre>
<h3>Notes</h3>
<P><A name="1">[1]</A>
Note that this is very similar to the behavior of <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>:  The
only real difference is that while <tt>equal</tt> will simply return <tt>false</tt>
if the two ranges differ, <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt> returns the first location where
they do differ.  The expression <tt>equal(f1, l1, f2)</tt> is precisely equivalent
to the expression <tt>mismatch(f1, l1, f2).first == l1</tt>, and this is in
fact how <tt>equal</tt> could be implemented.
<h3>See also</h3>
<tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><!--<A href="search.html">-->search<!--</A>--></tt>, <tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>

<!--start footer--> 
<HR SIZE="6">
<p>
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
