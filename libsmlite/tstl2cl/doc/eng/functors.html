<HTML>
<Head>
<Title>Function Objects</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<!--end header-->
<p>
<H3><a href="index.html">Table of Contents</a></H3>
<hr size="6">
<BR Clear>
<H1>Function Objects</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left VAlign=top><b>Category</b>: functors</TD>
<TD Align=right VAlign=top><b>Component type</b>: overview</TD>
</TR>
</Table>

<h3>Summary</h3>
A <i>Function Object</i>, or <i>Functor</i> (the two terms are synonymous)
is simply any object that can be called as if it is a function.
An ordinary function is a function object, and so is a function pointer;
more generally, so is an object of a class that defines
<tt>operator()</tt>.
<h3>Description</h3>
The basic function object concepts are <!--<A href="Generator.html">-->Generator<!--</A>-->,
<A href="UnaryFunction.html">Unary Function</A>, and <A href="BinaryFunction.html">Binary Function</A>: these describe,
respectively, objects that can be called as <tt>f()</tt>, <tt>f(x)</tt>, and
<tt>f(x,y)</tt>.  (This list could obviously be extended to <i>ternary function</i>
and beyond, but, in practice, no STL algorithms require function
objects of more than two arguments.)  All other function object
concepts defined by the STL are refinements of these three.
<P>
Function objects that return <tt>bool</tt> are
an important special case.
A <A href="UnaryFunction.html">Unary Function</A> whose return type is <tt>bool</tt> is called a
<A href="Predicate.html">Predicate</A>, and a <A href="BinaryFunction.html">Binary Function</A> whose return type is 
<tt>bool</tt> is called a <A href="BinaryPredicate.html">Binary Predicate</A>.
<P>
There is an important distinction, but a somewhat subtle one, between
function objects and <i>adaptable function objects</i>. <A href="#1">[1]</A>  In general, a
function object has restrictions on the type of its argument.  The
type restrictions need not be simple, though: <tt>operator()</tt> may be
overloaded, or may be a member template, or both.  Similarly, there
need be no way for a program to determine what those restrictions are.
An adaptable function object, however, does specify what the argument
and return types are, and provides nested <tt>typedef</tt>s so that those
types can be named and used in programs.  If a type <tt>F0</tt> is a model of
<!--<A href="AdaptableGenerator.html">-->Adaptable Generator<!--</A>-->, then it must define
<tt>F0::result_type</tt>.  Similarly, if <tt>F1</tt> is a model of 
<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>--> then it must define 
<tt>F1::argument_type</tt> and <tt>F1::result_type</tt>, and if <tt>F2</tt> is a model
of <!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>--> then it must define 
<tt>F2::first_argument_type</tt>, <tt>F2::second_argument_type</tt>, and
<tt>F2::result_type</tt>.
The STL provides base classes <tt><A href="unary_function.html">unary_function</A></tt> and
<tt><A href="binary_function.html">binary_function</A></tt> to simplify the definition of
<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Functions<!--</A>--> and <!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Functions<!--</A>-->. <A href="#2">[2]</A>
<P>
Adaptable function objects are important because they can be used by
<i>function object adaptors</i>: function objects that transform or
manipulate other function objects.  The STL provides many different
function object adaptors, including <tt><!--<A href="unary_negate.html">-->unary_negate<!--</A>--></tt> (which returns
the logical complement of the value returned by a particular
<!--<A href="AdaptablePredicate.html">-->AdaptablePredicate<!--</A>-->), and <tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt> and
<tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>, which perform composition of function object.
<P>
<!--
Finally, the STL includes many different predefined function 
objects, including arithmetic operations
(<tt><A href="plus.html">plus</A></tt>, <tt><A href="minus.html">minus</A></tt>, <tt><A href="times.html">multiplies</A></tt>, <tt><A href="divides.html">divides</A></tt>, <tt><A href="modulus.html">modulus</A></tt>,
and <tt><A href="negate.html">negate</A></tt>), comparisons (<tt><A href="equal_to.html">equal_to</A></tt>, <tt><A href="not_equal_to.html">not_equal_to</A></tt>
<tt><A href="greater.html">greater</A></tt>, <tt><A href="less.html">less</A></tt>, <tt><A href="greater_equal.html">greater_equal</A></tt>, and <tt><A href="less_equal.html">less_equal</A></tt>),
and logical operations (<tt><A href="logical_and.html">logical_and</A></tt>, <tt><A href="logical_or.html">logical_or</A></tt>, and
<tt><A href="logical_not.html">logical_not</A></tt>).  It is possible to perform very sophisticated
operations without actually writing a new function object, simply
by combining predefined function objects and function object
adaptors.-->
<h3>Examples</h3>
<pre>

</pre>
<h3>Concepts</h3>
<UL>
<LI>
<!--<A href="Generator.html">-->Generator<!--</A>-->
<LI>
 <A href="UnaryFunction.html">Unary Function</A>
<LI>
 <A href="BinaryFunction.html">Binary Function</A>
</UL>
<UL>
<LI>
 <A href="Predicate.html">Predicate</A>
<LI>
 <A href="BinaryPredicate.html">Binary Predicate</A>
</UL>
<UL>
<LI>
<!--<A href="AdaptableGenerator.html">-->Adaptable Generator<!--</A>-->
<LI>
<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
<LI>
<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
<LI>
<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->
<LI>
<!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
</UL>
<h3>Types</h3>
<UL>
<LI>
<tt><!--<A href="plus.html">-->plus<!--</A>--></tt>
<LI>
<tt><!--<A href="minus.html">-->minus<!--</A>--></tt>
<LI>
<tt><!--<A href="times.html">-->multiplies<!--</A>--></tt> (formerly called <tt>times</tt>)
<LI>
<tt><!--<A href="divides.html">-->divides<!--</A>--></tt>
<LI>
<tt><!--<A href="modulus.html">-->modulus<!--</A>--></tt>,
<LI>
<tt><!--<A href="negate.html">-->negate<!--</A>--></tt>
<LI>
<tt><!--<A href="equal_to.html">-->equal_to<!--</A>--></tt>
<LI>
<tt><!--<A href="not_equal_to.html">-->not_equal_to<!--</A>--></tt>
<LI>
<tt><!--<A href="greater.html">-->greater<!--</A>--></tt>
<LI>
<tt><!--<A href="less.html">-->less<!--</A>--></tt>
<LI>
<tt><!--<A href="greater_equal.html">-->greater_equal<!--</A>--></tt>
<LI>
<tt><!--<A href="less_equal.html">-->less_equal<!--</A>--></tt>,
<LI>
<tt><!--<A href="logical_and.html">-->logical_and<!--</A>--></tt>
<LI>
<tt><!--<A href="logical_or.html">-->logical_or<!--</A>--></tt>
<LI>
<tt><!--<A href="logical_not.html">-->logical_not<!--</A>--></tt>
<LI>
<tt><!--<A href="subtractive_rng.html">-->subtractive_rng<!--</A>--></tt>
</UL>
<UL>
<LI>
<tt><A href="identity.html">identity</A></tt>
<LI>
<tt><!--<A href="project1st.html">-->project1st<!--</A>--></tt>
<LI>
<tt><!--<A href="project2nd.html">-->project2nd<!--</A>--></tt>
<LI>
<tt><A href="select1st.html">select1st</A></tt>
<LI>
<tt><!--<A href="select2nd.html">-->select2nd<!--</A>--></tt>
</UL>
<UL>
<LI>
<tt><A href="unary_function.html">unary_function</A></tt>
<LI>
<tt><A href="binary_function.html">binary_function</A></tt>
</UL>
<UL>
<LI>
<tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt>
<LI>
<tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>
<LI>
<tt><A href="unary_negate.html">unary_negate</A></tt>
<LI>
<tt><A href="binary_negate.html">binary_negate</A></tt>
<LI>
<tt><!--<A href="binder1st.html">-->binder1st<!--</A>--></tt>
<LI>
<tt><!--<A href="binder2nd.html">-->binder2nd<!--</A>--></tt>
<LI>
<tt><!--<A href="pointer_to_unary_function.html">-->pointer_to_unary_function<!--</A>--></tt>
<LI>
<tt><!--<A href="pointer_to_binary_function.html">-->pointer_to_binary_function<!--</A>--></tt>
</UL>
<h3>Functions</h3>
<UL>
<LI>
<tt><!--<A href="unary_compose.html">-->compose1<!--</A>--></tt>
<LI>
<tt><!--<A href="binary_compose.html">-->compose2<!--</A>--></tt>
<LI>
<tt><A href="unary_negate.html">not1</A></tt>
<LI>
<tt><A href="binary_negate.html">not2</A></tt>
<LI>
<tt><!--<A href="binder1st.html">-->bind1st<!--</A>--></tt>
<LI>
<tt><!--<A href="binder2nd.html">-->bind2nd<!--</A>--></tt>
<LI>
<tt><!--<A href="ptr_fun.html">-->ptr_fun<!--</A>--></tt>
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
The reason for the name &quot;adaptable function object&quot; is that
adaptable function objects may be used by function object adaptors.
<P><A name="2">[2]</A>
The <tt><A href="unary_function.html">unary_function</A></tt> and <tt><A href="binary_function.html">binary_function</A></tt> bases are
similar to the <tt><!--<A href="input_iterator.html">-->input_iterator<!--</A>--></tt>, <tt><!--<A href="output_iterator.html">-->output_iterator<!--</A>--></tt>,
<tt><!--<A href="forward_iterator.html">-->forward_iterator<!--</A>--></tt>, <tt><!--<A href="bidirectional_iterator.html">-->bidirectional_iterator<!--</A>--></tt>, and
<tt><!--<A href="random_access_iterator.html">-->random_access_iterator<!--</A>--></tt> bases: they are completely empty,
and serve only to provide type information.
<P><A name="3">[3]</A>
This is an example of how to use function objects; it is not
the recommended way of calculating the sum of elements in a vector.
The <tt><!--<A href="accumulate.html">-->accumulate<!--</A>--></tt> algorithm is a better way of calculating a sum.
<h3>See also</h3>

<!--start footer--> 
<HR SIZE="6">
<p>
<H3><a href="index.html">Table of Contents</a></H3>
</BODY>
</HTML> 
