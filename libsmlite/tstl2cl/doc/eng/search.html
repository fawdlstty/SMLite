<HTML>
	<Head>
		<meta name="vs_showGrid" content="False">
		<Title>search</Title> 
		<!-- Generated by htmldoc -->
	</Head>
	<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" ALINK="#ff0000">
		<!--end header-->
		<p>
			<H3><a href="index.html">Table of Contents</a></H3>
			<hr size="6">
			<BR>
			<H1>search</H1>
			<Table CellPadding="0" CellSpacing="0" width="100%">
				<TR>
					<TD Align="left" VAlign="top"><b>Category</b>: algorithms</TD>
					<TD Align="right" VAlign="top"><b>Component type</b>: function</TD>
				</TR>
			</Table>
			<h3>Prototype</h3>
			<pre>
c_iterator c_search(c_iterator first1, c_iterator last1, c_iterator first2, c_iterator last2, BINARY_PREDICATE pf);
</pre>
			<h3>Description</h3>
			<tt>Search</tt> finds a subsequence within the range <tt>[first1, last1)</tt> that 
			is identical to <tt>[first2, last2)</tt> when compared element-by-element. It 
			returns an iterator pointing to the beginning of that subsequence, or else <tt>last1</tt>
			if no such subsequence exists. Using the user-supplied <A href="functors.html">function 
				object</A> <tt>binary_pred</tt>
		to determine whether two elements are the same.
		<P>
			The search algorithm returns the first iterator <tt>i</tt> in <tt>[first1, last1 - 
				(last2 - first2))</tt> such that, for every iterator <tt>j</tt> in <tt>[first2, 
				last2)</tt>, <tt>binary_pred(*(i + (j - first2)), *j)</tt> is <tt>true</tt>. 
			These conditions simply mean that every element in the subrange beginning with <tt>i</tt>
			must be the same as the corresponding element in <tt>[first2, last2)</tt>.
			<h3>Definition</h3>
			Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, 
			and in the nonstandard backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
			<h3>Requirements on types</h3>
			<UL>
				<LI>
					<tt>ForwardIterator1</tt> is a model of <A href="ForwardIterator.html">Forward 
						Iterator</A>.
				<LI>
					<tt>ForwardIterator2</tt> is a model of <A href="ForwardIterator.html">Forward 
						Iterator</A>.
				<LI>
					<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary 
						Predicate</A>.
				<LI>
					<tt>ForwardIterator1</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s 
				first argument type.
				<LI>
					<tt>ForwardIterator2</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s 
					second argument type.</LI>
			</UL>
			<h3>Preconditions</h3>
			<UL>
				<LI>
					<tt>[first1, last1)</tt>
				is a valid range.
				<LI>
					<tt>[first2, last2)</tt> is a valid range.</LI>
			</UL>
			<h3>Complexity</h3>
			Worst case behavior is quadratic: at most <tt>(last1 - first1) * (last2 - first2)</tt>
			comparisons. This worst case, however, is rare. Average complexity is linear.
			<h3>Example</h3>
			&nbsp;&nbsp;int ary[] = { 0,1,2,3,4,5,6,7,8,9 };<br>
			&nbsp;&nbsp;int * pary[] = { &amp;ary[0], &amp;ary[1], &amp;ary[2], &amp;ary[3], &amp;ary[4], &amp;ary[5], &amp;ary[6], &amp;ary[7], &amp;ary[8], &amp;ary[9] };<br>
			&nbsp;&nbsp;c_iterator first = c_get_array_iterator((void **)&amp;pary[0]);<br> 
			&nbsp;&nbsp;c_iterator last = c_get_array_iterator((void **)&amp;pary[10]);<br> 
			&nbsp;&nbsp;int * tmppary[] = { &amp;ary[3], &amp;ary[2], &amp;ary[1], &amp;ary[0], &amp;ary[4], &amp;ary[5], &amp;ary[6], &amp;ary[7], &amp;ary[8], &amp;ary[9], 0 };<br> 
			&nbsp;&nbsp;c_iterator result;<br> 
			&nbsp;&nbsp;result = c_search(first, last, c_get_array_iterator((void **)&amp;tmppary[0]), c_get_array_iterator((void **)&amp;tmppary[1]), is_int_equal);<br>
			<h3>Notes</h3>
		<P>The reason that this range is <tt>[first1, last1 - (last2 - 
				first2))</tt>, instead of simply <tt>[first1, last1)</tt>, is that we are 
			looking for a subsequence that is equal to the <i>complete</i> sequence <tt>[first2, 
				last2)</tt>. An iterator <tt>i</tt> can't be the beginning of such a 
			subsequence unless <tt>last1 - i</tt> is greater than or equal to <tt>last2 - 
				first2</tt>. Note the implication of this: you may call <tt>search</tt> with 
			arguments such that <tt>last1 - first1</tt> is less than <tt>last2 - first2</tt>, 
			but such a search will always fail.
			<h3>See also</h3>
			<tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>,
			<tt><!--<A href="find_end.html">-->find_end<!--</A>--></tt>, <tt><!--<A href="search_n.html">-->search_n<!--</A>--></tt>,
			<tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><A href="equal.html">equal</A></tt>
			<!--start footer-->
			<HR SIZE="6"><p>
			<H3><a href="index.html">Table of Contents</a></H3>
		</BODY>
</HTML> 
